<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Wang He"><meta name="description" content="这篇文章简单实现了curry函数，主要是为了巩固实现过程中用到的js知识，并且更深刻的了解函数柯里化的概念。"><meta name="keywords" content="js进阶"><title>函数柯里化实现初探 · Forino</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://wanghewanghe.github.io/2017/05/08/函数柯里化初探/"><link rel="alternate" href="/atom.xml" title="Forino"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Forino</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">函数柯里化实现初探</h1><span class="post-time">2017年5月8日</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#预备阶段"><span class="toc-text">预备阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初步实现"><span class="toc-text">初步实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#另一个版本"><span class="toc-text">另一个版本</span></a></li></ol></div><div class="post-content"><p>这篇文章简单实现了curry函数，主要是为了巩固实现过程中用到的js知识，并且更深刻的了解函数柯里化的概念。<br><a id="more"></a></p>
<hr>
<p>函数柯里化是和函数式编程密切相关的一个概念，可以先读下面的这篇文章，<br><a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying" target="_blank" rel="external">张鑫旭–js中的柯里化</a>，初步的理解这个概念。</p>
<p>概括来讲，函数柯里化的作用和特点就是参数复用，提前返回，延迟执行。下面通过代码来初探函数柯里化的实现。</p>
<h2 id="预备阶段"><a href="#预备阶段" class="headerlink" title="预备阶段"></a>预备阶段</h2><p>  首先需要接受或者习惯一个js的基础知识，因为平时代码中用的不多，所以刚开始看到代码还会有点陌生和不知所云。其实就是基础知识罢了。<br>  下面用es5和es6两种写法来写，方便理解，在比较中也可以更好的学习es6。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(a) &#123;</div><div class="line">  return function(b) &#123;</div><div class="line">    return a + b</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const add = a =&gt; b =&gt; a + b</div></pre></td></tr></table></figure>
<p>  我们定义了一个求和函数，但是，调用方法有些特殊：<code>add(1)(2);  // 3</code>。<br>  如果我们分开来调用，就可以看得更加明显：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const add1 = add(1);      // 这里就体现了参数复用的特点</div><div class="line">add1(2);     // 3</div></pre></td></tr></table></figure></p>
<p>  总结下：</p>
<ol>
<li>将一般的求和函数<code>const sum = (a, b, c) =&gt; a + b + c</code>转化为<code>const add = a =&gt; b =&gt; c =&gt; a + b + c</code>的过程，就叫做函数的柯里化过程。转化而来的函数就是柯里化函数。</li>
<li><code>fn(a)(b)(c)</code>这种调用函数的方法，意味着fn接受一个参数a，然后返回了一个函数接受参数b，又返回了一个函数接受参数c……最后，将所有的参数进行处理。</li>
</ol>
<h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>  下面我们尝试实现一个curry函数，它的作用就是将一个函数柯里化，即<code>curry(sum)(a)(b)(c) &lt;==&gt; add(a)(b)(c)</code></p>
<p>  通过上面的分析，可以有个初步的思路，我们先定义一个数组，将函数的参数依次收集起来，然后将这些参数加起来.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function curry(fn) &#123;</div><div class="line">  var arr = [];</div><div class="line">  return function curring() &#123;</div><div class="line">    var arg = [].slice.call(arguments);</div><div class="line">    arr = arr.concat(arg);</div><div class="line">    if (arr.legnth &lt; fn.length) &#123;</div><div class="line">      return curring;</div><div class="line">    &#125;</div><div class="line">    return fn.apply(this, arr);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const curry = fn =&gt; &#123;</div><div class="line">  let arr = [];</div><div class="line">  const curring = (...arg) =&gt; &#123;</div><div class="line">    arr = arr.concat(arg);</div><div class="line">    return arr.length &lt; fn.length ? curring : fn.apply(this, arr);</div><div class="line">  &#125;</div><div class="line">  return curring</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  上面的代码用到了闭包保存我们收集参数的数组，通过递归来依次收集参数（这里用到了function的length属性，这个属性会返回一个函数预期传入的参数个数，也就是形式参数的个数）。</p>
<p>  如果还是不理解，可以在浏览器里分步执行，比如<code>curry(sum)(1)(2)(3)</code>，curry一共执行了三次，arg分别是[1], [2], [3]，arr分别是[], [1], [1, 2]；另外，函数中的this一直指向的window。</p>
<p>  补充一下，这个柯里化函数还可以每次传入不定的参数进行调用，如<code>curry(sum)(1, 2)(3)</code>或者<code>curry(sum)(1, 2, 3)</code></p>
<h2 id="另一个版本"><a href="#另一个版本" class="headerlink" title="另一个版本"></a>另一个版本</h2><p>  不多废话了，直接看代码<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const curry = (fn, arr = []) =&gt; (</div><div class="line">     (...arg) =&gt; (</div><div class="line">         a =&gt; a.length === fn.length ? fn(...a) : curry(fn, a)</div><div class="line">       )([...arr, ...arg])</div><div class="line">  )</div></pre></td></tr></table></figure></p>
<p>  因为最初看到的这个版本就是es6的，感觉比上面的更加简练一点，当然也更加装逼。。。下面试着用es5的方法改写一下(也可以去babel官网进行转译)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function curry(fn, arr) &#123;</div><div class="line">  var arr = (arr !== undefined &amp;&amp; arr !== null) ? arr : [];</div><div class="line">  return function() &#123;</div><div class="line">    var arg = [].slice.call(arguments)</div><div class="line">    return (function(a) &#123;</div><div class="line">      return a.length === fn.length ? fn.apply(this, a) : curry(fn, a)</div><div class="line">    &#125;)(arr.concat(arg))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div></article><div class="tags"><a href="/tags/js进阶/">js进阶</a></div><div class="paginator"><a id="next" href="/2017/04/09/FDCon2017-中国前端开发者大会笔记/" data-title="FDCon2017 中国前端开发者大会笔记" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div data-thread-key="http://wanghewanghe.github.io/2017/05/08/函数柯里化初探/index.html" data-title="函数柯里化实现初探" data-url="http://wanghewanghe.github.io/2017/05/08/函数柯里化初探/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "wanghe830" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section></section><footer><div class="social"><a href="mailto:893079286@qq.com" title="email" class="iconfont icon-email"></a><a href="https://github.com/wanghewanghe" title="github" class="iconfont icon-github"></a><a href="/atom.xml" title="rss" class="iconfont icon-rss"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Wang He</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>