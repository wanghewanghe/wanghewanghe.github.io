<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Wang He"><meta name="description" content="这篇文章简单实现了curry函数，主要是为了巩固实现过程中用到的js知识，并且更深刻的了解函数柯里化的概念。"><meta name="keywords" content="js进阶"><title>函数柯里化实现初探 · Forino</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://wanghewanghe.github.io/2017/05/08/函数柯里化初探/"><link rel="alternate" href="/atom.xml" title="Forino"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Forino</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">函数柯里化实现初探</h1><span class="post-time">2017年5月8日</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#预备阶段"><span class="toc-text">预备阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初步实现"><span class="toc-text">初步实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#另一个版本"><span class="toc-text">另一个版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#what’s-more"><span class="toc-text">what’s more</span></a></li></ol></div><div class="post-content"><p>这篇文章简单实现了curry函数，主要是为了巩固实现过程中用到的js知识，并且更深刻的了解函数柯里化的概念。<br><a id="more"></a></p>
<hr>
<p>函数柯里化是和函数式编程密切相关的一个概念，可以先读下面的这篇文章，<br><a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying" target="_blank" rel="external">张鑫旭–js中的柯里化</a>，初步的理解这个概念。</p>
<p>概括来讲，函数柯里化的作用和特点就是参数复用，提前返回，延迟执行。下面通过代码来初探函数柯里化的实现。</p>
<h2 id="预备阶段"><a href="#预备阶段" class="headerlink" title="预备阶段"></a>预备阶段</h2><p>  首先需要接受或者习惯一个js的基础知识，因为平时代码中用的不多，所以刚开始看到代码还会有点陌生和不知所云。其实就是基础知识罢了。<br>  下面用es5和es6两种写法来写，方便理解，在比较中也可以更好的学习es6。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(a) &#123;</div><div class="line">  return function(b) &#123;</div><div class="line">    return a + b</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const add = a =&gt; b =&gt; a + b</div></pre></td></tr></table></figure>
<p>  我们定义了一个求和函数，但是，调用方法有些特殊：<code>add(1)(2);  // 3</code>。<br>  如果我们分开来调用，就可以看得更加明显：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const add1 = add(1);      // 这里就体现了参数复用的特点</div><div class="line">add1(2);     // 3</div></pre></td></tr></table></figure></p>
<p>  总结下：</p>
<ol>
<li>将一般的求和函数<code>const sum = (a, b, c) =&gt; a + b + c</code>转化为<code>const add = a =&gt; b =&gt; c =&gt; a + b + c</code>的过程，就叫做函数的柯里化过程。转化而来的函数就是柯里化函数。</li>
<li><code>fn(a)(b)(c)</code>这种调用函数的方法，意味着fn接受一个参数a，然后返回了一个函数接受参数b，又返回了一个函数接受参数c……最后，将所有的参数进行处理。</li>
</ol>
<h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>  下面我们尝试实现一个curry函数，它的作用就是将一个函数柯里化，即<code>curry(sum)(a)(b)(c) &lt;==&gt; add(a)(b)(c)</code></p>
<p>  通过上面的分析，可以有个初步的思路，我们先定义一个数组，将函数的参数依次收集起来，然后将这些参数加起来.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function curry(fn) &#123;</div><div class="line">  var arr = [];</div><div class="line">  return function curring() &#123;</div><div class="line">    var arg = [].slice.call(arguments);</div><div class="line">    arr = arr.concat(arg);</div><div class="line">    if (arr.legnth &lt; fn.length) &#123;</div><div class="line">      return curring;</div><div class="line">    &#125;</div><div class="line">    return fn.apply(this, arr);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const curry = fn =&gt; &#123;</div><div class="line">  let arr = [];</div><div class="line">  const curring = (...arg) =&gt; &#123;</div><div class="line">    arr = arr.concat(arg);</div><div class="line">    return arr.length &lt; fn.length ? curring : fn.apply(this, arr);</div><div class="line">  &#125;</div><div class="line">  return curring</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  上面的代码用到了闭包保存我们收集参数的数组，通过递归来依次收集参数（这里用到了function的length属性，这个属性会返回一个函数预期传入的参数个数，也就是形式参数的个数）。</p>
<p>  如果还是不理解，可以在浏览器里分步执行，比如<code>curry(sum)(1)(2)(3)</code>，curry一共执行了三次，arg分别是[1], [2], [3]，arr分别是[], [1], [1, 2]；另外，函数中的this一直指向的window。</p>
<p>  补充一下，这个柯里化函数还可以每次传入不定的参数进行调用，如<code>curry(sum)(1, 2)(3)</code>或者<code>curry(sum)(1, 2, 3)</code></p>
<h2 id="另一个版本"><a href="#另一个版本" class="headerlink" title="另一个版本"></a>另一个版本</h2><p>  不多废话了，直接看代码<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const curry = (fn, arr = []) =&gt; (</div><div class="line">     (...arg) =&gt; (</div><div class="line">         a =&gt; a.length === fn.length ? fn(...a) : curry(fn, a)</div><div class="line">       )([...arr, ...arg])</div><div class="line">  )</div></pre></td></tr></table></figure></p>
<p>  因为最初看到的这个版本就是es6的，感觉比上面的更加简练一点，当然也更加装逼。。。仔细分析一下可以看到，这个版本通过一个默认参数和一个立即执行函数，避免了定义收集参数的数组arr，通过灵活使用扩展运算符，替代了arguments对象也完成了数组的拼接。</p>
<p>  下面试着用es5的方法改写一下，加深理解<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function curry(fn, arr) &#123;</div><div class="line">  var arr = (arr !== undefined &amp;&amp; arr !== null) ? arr : [];</div><div class="line">  return function() &#123;</div><div class="line">    var arg = [].slice.call(arguments)</div><div class="line">    return (function(a) &#123;</div><div class="line">      return a.length === fn.length ? fn.apply(this, a) : curry(fn, a)</div><div class="line">    &#125;)(arr.concat(arg))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  上面是我改写的版本，有个地方明显是没改好，就是最后<code>[...arr, ...arg]</code>这里，我直接改写为concat了。由于扩展运算符也可以用于处理字符串，和类数组，所以直接改成concat不是很合理。但是理解这个函数的思路是够用了。</p>
<p>  下面是我在babel官网进行转译的结果，看看babel是怎么处理扩展运算符的。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function _toConsumableArray(arr) &#123;</div><div class="line">  if (Array.isArray(arr)) &#123;</div><div class="line">    for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) arr2[i] = arr[i];</div><div class="line">    return arr2;</div><div class="line">  &#125; else &#123;</div><div class="line">    return Array.from(arr);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var curry = function curry(fn) &#123;</div><div class="line">  var arr = arguments.length &lt;= 1 || arguments[1] === undefined ? [] : arguments[1];</div><div class="line">  return function () &#123;</div><div class="line">      for (var _len = arguments.length, arg = Array(_len), _key = 0; _key &lt; _len; _key++) &#123;</div><div class="line">          arg[_key] = arguments[_key];</div><div class="line">      &#125;</div><div class="line">      return (function (a) &#123;</div><div class="line">          return a.length === fn.length ? fn.apply(undefined, _toConsumableArray(a)) : curry(fn, a);</div><div class="line">      &#125;)([].concat(_toConsumableArray(arr), arg));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>  从上面一系列的转化分析中可以看出，这个版本的curry函数可以接受第二个参数，这个参数必须能被扩展运算符操作，否则就会报错，比如一个数字。不过单纯实现我们的需求，这个版本是相对比较简单的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  这篇文章涉及到的js知识有：</p>
<ul>
<li>函数柯里化</li>
<li>闭包</li>
<li>函数的length属性</li>
<li>函数的call和apply方法</li>
<li>函数的arguments对象</li>
<li>es6的箭头函数和扩展运算符</li>
<li>函数的递归</li>
<li>立即执行函数<h2 id="what’s-more"><a href="#what’s-more" class="headerlink" title="what’s more"></a>what’s more</h2>一些javascript库早就提供了curry方法，比如大名鼎鼎的lodash。lodash的curry函数就比上面的版本更加健壮，当然其源码也更加复杂。<br>下面是lodash的curry方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates a function that accepts arguments of `func` and either invokes</div><div class="line"> * `func` returning its result, if at least `arity` number of arguments have</div><div class="line"> * been provided, or returns a function that accepts the remaining `func`</div><div class="line"> * arguments, and so on. The arity of `func` may be specified if `func.length`</div><div class="line"> * is not sufficient.</div><div class="line"> *</div><div class="line"> * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,</div><div class="line"> * may be used as a placeholder for provided arguments.</div><div class="line"> *</div><div class="line"> * **Note:** This method doesn&apos;t set the &quot;length&quot; property of curried functions.</div><div class="line"> *</div><div class="line"> * @static</div><div class="line"> * @memberOf _</div><div class="line"> * @since 2.0.0</div><div class="line"> * @category Function</div><div class="line"> * @param &#123;Function&#125; func The function to curry.</div><div class="line"> * @param &#123;number&#125; [arity=func.length] The arity of `func`.</div><div class="line"> * @param- &#123;Object&#125; [guard] Enables use as an iteratee for methods like `_.map`.</div><div class="line"> * @returns &#123;Function&#125; Returns the new curried function.</div><div class="line"> * @example</div><div class="line"> *</div><div class="line"> * var abc = function(a, b, c) &#123;</div><div class="line"> *   return [a, b, c];</div><div class="line"> * &#125;;</div><div class="line"> *</div><div class="line"> * var curried = _.curry(abc);</div><div class="line"> *</div><div class="line"> * curried(1)(2)(3);</div><div class="line"> * // =&gt; [1, 2, 3]</div><div class="line"> *</div><div class="line"> * curried(1, 2)(3);</div><div class="line"> * // =&gt; [1, 2, 3]</div><div class="line"> *</div><div class="line"> * curried(1, 2, 3);</div><div class="line"> * // =&gt; [1, 2, 3]</div><div class="line"> *</div><div class="line"> * // Curried with placeholders.</div><div class="line"> * curried(1)(_, 3)(2);</div><div class="line"> * // =&gt; [1, 2, 3]</div><div class="line"> */</div><div class="line">function curry(func, arity, guard) &#123;</div><div class="line">  arity = guard ? undefined : arity;</div><div class="line">  var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);</div><div class="line">  result.placeholder = curry.placeholder;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</div></article><div class="tags"><a href="/tags/js进阶/">js进阶</a></div><div class="paginator"><a id="next" href="/2017/04/09/FDCon2017-中国前端开发者大会笔记/" data-title="FDCon2017 中国前端开发者大会笔记" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div data-thread-key="http://wanghewanghe.github.io/2017/05/08/函数柯里化初探/index.html" data-title="函数柯里化实现初探" data-url="http://wanghewanghe.github.io/2017/05/08/函数柯里化初探/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "wanghe830" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section></section><footer><div class="social"><a href="mailto:893079286@qq.com" title="email" class="iconfont icon-email"></a><a href="https://github.com/wanghewanghe" title="github" class="iconfont icon-github"></a><a href="/atom.xml" title="rss" class="iconfont icon-rss"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Wang He</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>